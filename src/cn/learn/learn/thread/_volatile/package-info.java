/**
 * @author Fuzhong
 *
 */
package cn.learn.learn.thread._volatile;

/*

1)——>原子性:即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
	在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
	x = 10;        //语句1：是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
	y = x;         //语句2：实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
	x++;           //语句3：同上
	x = x + 1;     //语句4：同上
	Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
	由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

2)——>可见性:指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
	对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
	而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
	另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

3)——>有序性:即程序执行的顺序按照代码的先后顺序执行。
	 虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同,因为处理器在进行重排序时是会考虑指令之间的数据依赖性，
	 如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
	 虽然指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
	 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。
	 另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
	Java内存模型具备一些先天的“有序性”：
	1·程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
	2.锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
	3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
	4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
	5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
	6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
	7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
	8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

volatile关键字的两层语义：

1)保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2)禁止进行指令重排序。
	1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
	2.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

解释：

1)使用volatile关键字会强制将修改的值立即写入主存；
2)使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
3)由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。

注意:
	1)volatile关键字保证了操作的可见性，但是volatile不能保证对变量的操作是原子性
	
	2)在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，
	保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。
	
volatile关键字的场景:
	synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，
	但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：
	1)对变量的写操作不依赖于当前值
	2)该变量没有包含在具有其他变量的不变式中


*/